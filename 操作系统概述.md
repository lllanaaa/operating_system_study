## 1、操作系统概述

### 1.1、什么是操作系统

操作系统是计算机硬件和应用之间的一层软件，管理基本的计算机硬件

- CPU管理
- 内存管理
- 终端管理
- 磁盘管理
- 文件管理



### 1.2、操作系统的启动

一、计算机的发展

- 从白纸到图灵机

  ![image-20200927030519847](D:\study\操作系统\操作系统概述.assets\image-20200927030519847.png)

- 从图灵机到通用图灵机

  ![image-20200927030629503](D:\study\操作系统\操作系统概述.assets\image-20200927030629503.png)

- 从通用图灵机到计算机

  **取值执行**

  ![image-20200927023449217](C:\Users\ye\AppData\Roaming\Typora\typora-user-images\image-20200927023449217.png)



二、打开电源，计算机执行的第一句指令

0磁道0扇区：引导扇区

1. 引导扇区代码：bootsect.s（s是汇编的意思 这里是16位汇编）
   
- 功能：读入操作系统的代码放入内存：读入setup，在屏幕上打出loading system，读入system
  
2. setup模块：setup.s（这里是16位汇编）

   - 功能：完成OS启动前的设置（读了一些硬件参数）、把system挪到0x0000处

   - 进入保护模式 

     ```
     mov ax, #0x0001
     mov cr0, ax   // cr0寄存器 PE=1启动保护模式
     jmpi 0, 8   // ip=8 cs=8 32位指令
     ```

     在保护模式下 int n 和 cs:ip 解释不再和实模式一样

     实模式下：cs左移4 + ip

     保护模式下：根据cs查表 + ip（表就是gdt Global Descriptor Table全局描述表）、int n 根据 idt 去查询中断处理函数入口

3. system模块
   - system模块的第一部分代码：head.s
     - head.s 初始化 IDT 表和 GDT 表（这里是32位汇编代码）执行完跳到 main.c
   - linux/Makefile

4. init/main.c

   - ![image-20200927175447848](D:\study\操作系统\操作系统概述.assets\image-20200927175447848.png)

     功能：xx_init 内存、中断、设备、时钟、CPU等内容的初始化

   - eg. mem_init

     ![image-20200927175743977](D:\study\操作系统\操作系统概述.assets\image-20200927175743977.png)



总结：

- boot：将OS从磁盘上读入 

  setup：获得了一些参数，启动了保护模式

  head：初始化了GDT表和页表

  main：初始化内存

- 总的来说就是将操作系统读入内存，然后初始化





## 2、系统接口

### 2.1、操作系统接口

操作系统接口：连接上层用户和操作系统软件

用户使用计算机的方式：

- 命令行
  - 命令：用c语言写的程序
- 图形按钮
  - 图形界面：一个包括画图的c程序
- 应用程序



总结：操作系统接口就是系统调用

![image-20200927225247744](D:\study\操作系统\操作系统概述.assets\image-20200927225247744.png)



### 2.2、系统调用的实现

一、内核态/用户态

问题：系统调用和应用程序都在内存中，为什么不能jump和move？

内存被分割成了用户段和内核段

![image-20200927230847923](D:\study\操作系统\操作系统概述.assets\image-20200927230847923.png)

内核态可以访问任何数据，用户态不能访问内核数据 

如果DPL（目标特权级）>= CPL（当前特权级），那么当前就不能访问内核数据



eg.

![image-20200927231408483](D:\study\操作系统\操作系统概述.assets\image-20200927231408483.png)

红色的是操作系统里面的数据

在head.s执行的时候会针对内核态的代码和数据初始化GDT，DPL=0（DPL=0在GDT表中）

进入用户态去执行（从内核到用户态执行的时候会将CPL置为3），当启动用户态程序时，cs中的CPL为3（CPL在cs寄存器里）

在每次跳转或者move时都会访问GDT表，发现CPL=3，DPL=0，所以没法访问



二、中断指令int

硬件提供了 用户程序发起的唯一主动进入内核 的方法：中断指令int

int指令将cs中的CPL改为0，进入内核



三、系统调用

系统调用的核心：

- 用户程序中包含一段包含**int指令**的代码
- 操作系统写中断处理，获取想调程序的编号
- 操作系统根据编号执行相应代码



eg. printf()

![image-20200927232735334](D:\study\操作系统\操作系统概述.assets\image-20200927232735334.png)

write()展开成包含int指令的汇编代码：

![image-20200927232850844](D:\study\操作系统\操作系统概述.assets\image-20200927232850844.png)

![image-20200927233418975](D:\study\操作系统\操作系统概述.assets\image-20200927233418975.png)

- 关键是把 __NR_write 放入eax

  __NR_write是系统调用号

![image-20200927233830309](D:\study\操作系统\操作系统概述.assets\image-20200927233830309.png)

![image-20200927234346158](D:\study\操作系统\操作系统概述.assets\image-20200927234346158.png)

![image-20200927234441214](D:\study\操作系统\操作系统概述.assets\image-20200927234441214.png)

![image-20200927234535147](D:\study\操作系统\操作系统概述.assets\image-20200927234535147.png)

printf()通过库函数变成int 0x80代码

int 0x80在系统初始化的时候被做成一个system_call

接着调用sys_call_table去查表和__NR_write最后才能调用sys_write





回到之前的例子：

![image-20200927235025624](D:\study\操作系统\操作系统概述.assets\image-20200927235025624.png)

左边：不能直接jmp，因为不能让上层应用直接访问内核

CPL=3  DPL=0，所以不能进去

解决方法：

右边：用户设置系统调用号72，通过int 0x80指令才能穿过接口，这时候CPL=3，DPL=3，所以可以进去

进去以后CPL被置为0，然后执行_system_call，调用sys_whoami，这时候就可以访问内核数据了4





## 3、操作系统的历史

一、

1. 1955 - 1965 IBM7094

![image-20200928102537324](D:\study\操作系统\操作系统概述.assets\image-20200928102537324.png)

2. 1965 - 1980 OS/360

   ![image-20200928102834177](D:\study\操作系统\操作系统概述.assets\image-20200928102834177.png)

3. 1965 - 1980 MULTICS

   ![image-20200928104217897](D:\study\操作系统\操作系统概述.assets\image-20200928104217897.png)



4. 1980 - 1990 UNIX

![image-20200928104503953](D:\study\操作系统\操作系统概述.assets\image-20200928104503953.png)



5. 1990 - 2000 Linux

![image-20200928104842384](D:\study\操作系统\操作系统概述.assets\image-20200928104842384.png)



总结：IBSYS ->  OS/360 -> MULTICS -> Unix -> Linux

![image-20200928105101433](D:\study\操作系统\操作系统概述.assets\image-20200928105101433.png)

操作系统的基本图谱：**多进程结构**



二、

1. CP/M

   ![image-20200928105531681](D:\study\操作系统\操作系统概述.assets\image-20200928105531681.png)

2. QDOS和MS-DOS

   ![image-20200928105636690](D:\study\操作系统\操作系统概述.assets\image-20200928105636690.png)

3. Windows

   ![image-20200928105747034](D:\study\操作系统\操作系统概述.assets\image-20200928105747034.png)

4. Mac OS和iOS

   ![image-20200928105835537](D:\study\操作系统\操作系统概述.assets\image-20200928105835537.png)



总结：

CP/M -> QDOS -> MS-DOS -> Windows 

Unix -> System -> Mac OS -> iOS

![image-20200928105953586](D:\study\操作系统\操作系统概述.assets\image-20200928105953586.png)

操作系统的**文件操作视图**





